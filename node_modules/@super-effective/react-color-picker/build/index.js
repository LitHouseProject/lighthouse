'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var classNames = require('classnames');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Takes given cyan, magenta, yellow, and black values and returns the RGB representation
 * @param {number} cyan The cyan component of the color (percentage represented as 0 - 1)
 * @param {number} magenta The magenta component of the color (percentage represented as 0 - 1)
 * @param {number} yellow The yellow component of the color (percentage represented as 0 - 1)
 * @param {number} black The black component of the color (percentage represented as 0 - 1)
 * @returns {Rgb} The Rgb representation of the color
 */

/**
 * Takes given red, green, and blue values and returns the hex color representation
 * @param {number} red The red component of the color (0 - 255)
 * @param {number} green The green component of the color (0 - 255)
 * @param {number} blue The blue component of the color (0 - 255)
 * @returns {string} The hex string representation of the color
 */
function rgbToHex(red, green, blue) {
    var rgb = blue | (green << 8) | (red << 16);
    return "#" + (0x1000000 + rgb).toString(16).slice(1);
}

/**
 * Converts a hex color string to its red, green, and blue component values
 * @param {string} colorHex The color value in hex format
 * @returns {Rgb} The RGB values for the color
 */
function hexToRgb(colorHex) {
    var sanitizedHex = colorHex.replace(/[^a-fA-F0-9]/g, '');
    if (sanitizedHex.length !== 6 && sanitizedHex.length !== 3) {
        throw new Error("Color should be either 3 or 6 characters in length - received a length of " + sanitizedHex.length);
    }
    if (sanitizedHex.length === 3) {
        sanitizedHex = "" + sanitizedHex[0].repeat(2) + sanitizedHex[1].repeat(2) + sanitizedHex[2].repeat(2);
    }
    var rgb = parseInt(sanitizedHex, 16);
    if (Number.isNaN(rgb)) {
        throw new Error("Unable to parse hex color " + colorHex);
    }
    var red = (rgb >> 16) & 0xff;
    var green = (rgb >> 8) & 0xff;
    var blue = (rgb) & 0xff;
    return {
        red: red,
        green: green,
        blue: blue,
    };
}

/**
 * Takes given red, green, and blue values and returns the HSV representation
 * @param {number} red The red component of the color (0 - 255)
 * @param {number} green The green component of the color (0 - 255)
 * @param {number} blue The blue component of the color (0 - 255)
 * @returns {Hsv} The HSV representation of the color
 */
function rgbToHsv(red, green, blue) {
    var redPercent = red / 255;
    var greenPercent = green / 255;
    var bluePercent = blue / 255;
    var max = Math.max(redPercent, greenPercent, bluePercent);
    var min = Math.min(redPercent, greenPercent, bluePercent);
    var diff = max - min;
    var hue = 0;
    var saturation = (max === 0) ? 0 : diff / max;
    var value = max;
    if (min === max) ;
    else {
        switch (max) {
            case redPercent: {
                hue = (greenPercent - bluePercent) / diff + (greenPercent < bluePercent ? 6 : 0);
                break;
            }
            case greenPercent: {
                hue = (bluePercent - redPercent) / diff + 2;
                break;
            }
            case bluePercent: {
                hue = (redPercent - greenPercent) / diff + 4;
                break;
            }
        }
        hue /= 6;
        hue *= 360;
    }
    return {
        hue: hue,
        saturation: saturation,
        value: value,
    };
}

/**
 * Converts a hex color string to its hue, saturation, and value
 * @param {string} colorHex The color value in hex format
 * @returns {Hsv} The HSV values for the color
 */
function hexToHsv(colorHex) {
    // Hex validation handled by hexToRgb
    var _a = hexToRgb(colorHex), red = _a.red, green = _a.green, blue = _a.blue;
    return rgbToHsv(red, green, blue);
}

/**
 * Takes given hue, saturation and value and returns the respective RGB values
 * @param {number} hue The hue of the color (0.0 - 360.0)
 * @param {number} saturation The saturation of the color (0.0 - 1.0)
 * @param {number} value The value of the color (0.0 - 1.0)
 * @returns {Rgb} The RGB values for the color
 */
function hsvToRgb(hue, saturation, value) {
    // Bounds check
    if ((hue < 0 || hue > 360)
        || (saturation < 0 || saturation > 1)
        || (value < 0 || value > 1)) {
        throw new Error('Invalid hue, saturation, or value - all values must be between 0 and 1');
    }
    var red = 0;
    var green = 0;
    var blue = 0;
    var huePercent = hue / 360;
    var i = Math.floor(huePercent * 6);
    var f = huePercent * 6 - i;
    var p = value * (1 - saturation);
    var q = value * (1 - f * saturation);
    var t = value * (1 - (1 - f) * saturation);
    switch (i % 6) {
        case 0: {
            red = value;
            green = t;
            blue = p;
            break;
        }
        case 1: {
            red = q;
            green = value;
            blue = p;
            break;
        }
        case 2: {
            red = p;
            green = value;
            blue = t;
            break;
        }
        case 3: {
            red = p;
            green = q;
            blue = value;
            break;
        }
        case 4: {
            red = t;
            green = p;
            blue = value;
            break;
        }
        case 5: {
            red = value;
            green = p;
            blue = q;
            break;
        }
    }
    red = Math.round(red * 255);
    green = Math.round(green * 255);
    blue = Math.round(blue * 255);
    return {
        red: red,
        green: green,
        blue: blue,
    };
}

/**
 * Takes given hue, saturation and value and returns the hex color representation
 * @param {number} hue The hue of the color (0.0 - 360.0)
 * @param {number} saturation The saturation of the color (0.0 - 1.0)
 * @param {number} value The value of the color (0.0 - 1.0)
 * @returns {string} The hex string representation of the color
 */
function hsvToHex(hue, saturation, value) {
    // Bounds check handled by hsvToRgb
    var _a = hsvToRgb(hue, saturation, value), red = _a.red, green = _a.green, blue = _a.blue;
    return rgbToHex(red, green, blue);
}

/**
 * Removes invalid characters and formats color hex to 6 characters
 * @param {string} colorHex The color value in hex format to sanitize
 * @returns {string} The sanitized hex color
 */
function sanitizeHex(colorHex) {
    var sanitizedHex = colorHex.replace(/[^a-fA-F0-9]/g, '');
    if (sanitizedHex.length === 0) {
        sanitizedHex = '000000';
    }
    else if (sanitizedHex.length === 1) {
        sanitizedHex = sanitizedHex[0].repeat(6);
    }
    else if (sanitizedHex.length === 2) {
        sanitizedHex = "" + sanitizedHex[0].repeat(3) + sanitizedHex[1].repeat(3);
    }
    else if (sanitizedHex.length >= 3 && sanitizedHex.length < 6) {
        sanitizedHex = "" + sanitizedHex[0].repeat(2) + sanitizedHex[1].repeat(2) + sanitizedHex[2].repeat(2);
    }
    else if (sanitizedHex.length > 6) {
        sanitizedHex = sanitizedHex.substr(0, 6);
    }
    return "#" + sanitizedHex;
}

/**
 * Sanitize and combine classNames to a single string
 * @param  {string[]} classNames The classNames to combine
 * @returns {string} The combined class names
 */
/**
 * Get the hue value from a given position on the hue slider
 * @param {number} x The x coordinate on the hue slider
 * @param {number} width The width of the hue slider
 * @returns {number} The hue based on the x position
 */
function getHueFromPosition(x, width) {
    if (!width) {
        return 0;
    }
    var percentage = x / width;
    var hue = Math.max(Math.min(percentage, 1), 0) * 360;
    return hue;
}
/**
 * Get the saturation and value from a given position on the SV slider
 * @param {number} x The x coordinate on the SV selector
 * @param {number} y The y coordinate on the SV selector
 * @param {number} width The width of the SV selector
 * @param {number} height The height of the SV selector
 * @returns {SaturationValue} The saturation and value based on the position
 */
function getSaturationValueFromPosition(x, y, width, height) {
    var percentageX = (!width) ? 0 : x / width;
    var percentageY = (!height) ? 0 : 1 - (y / height);
    var saturation = Math.max(Math.min(percentageX, 1), 0);
    var value = Math.max(Math.min(percentageY, 1), 0);
    return {
        saturation: saturation,
        value: value,
    };
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$2 = ".HueSlider-module_hue_slider__3-jXT {\n  position: relative;\n  height: 28px;\n  margin-left: 11px;\n  margin-right: 11px;\n  margin-bottom: 2px;\n  background-image: linear-gradient(to left, #ff0000 0%, #ff00ff 16.66%, #0000ff 33.33%, #00ffff 50%, #00ff00 66.66%, #ffff00 80.33%, #ff0000 100%);\n}\n.HueSlider-module_hue_slider__3-jXT.HueSlider-module_vertical__2dAq_ {\n  width: 28px;\n  height: 100%;\n  background-image: linear-gradient(to top, #ff0000 0%, #ff00ff 16.66%, #0000ff 33.33%, #00ffff 50%, #00ff00 66.66%, #ffff00 80.33%, #ff0000 100%);\n}\n.HueSlider-module_hue_slider__3-jXT.HueSlider-module_vertical__2dAq_ .HueSlider-module_hue_slider_picker__1XZR2 {\n  top: 0;\n  left: -2px;\n  width: 100%;\n  height: 18px;\n  transform: translateY(-50%);\n}\n.HueSlider-module_hue_slider__3-jXT .HueSlider-module_hue_slider_picker__1XZR2 {\n  position: absolute;\n  top: -2px;\n  left: 0;\n  width: 18px;\n  height: 100%;\n  border: 2px solid #ffffff;\n  box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.5);\n  background-color: #ff0000;\n  border-radius: 11px;\n  cursor: pointer;\n  transform: translateX(-50%);\n}";
var styles$2 = {"hue_slider":"HueSlider-module_hue_slider__3-jXT","vertical":"HueSlider-module_vertical__2dAq_","hue_slider_picker":"HueSlider-module_hue_slider_picker__1XZR2"};
styleInject(css_248z$2);

var HueSlider = function (_a) {
    var _b;
    var className = _a.className, pickerClassName = _a.pickerClassName, hue = _a.hue, _c = _a.layout, layout = _c === void 0 ? 'HORIZONTAL' : _c, onChange = _a.onChange, _d = _a.onInteractionStart, onInteractionStart = _d === void 0 ? function () { } : _d, _e = _a.onInteractionEnd, onInteractionEnd = _e === void 0 ? function () { } : _e;
    var _f = react.useState(false), isInteracting = _f[0], setIsInteracting = _f[1];
    var sliderDivRef = react.useRef(null);
    var hueColor = hsvToHex(hue, 1, 1);
    var updateHue = react.useCallback(function (evt) {
        if (!sliderDivRef.current) {
            return;
        }
        var huePosition = sliderDivRef.current.getBoundingClientRect();
        switch (layout) {
            case HueSlider.LAYOUTS.VERTICAL: {
                var y = evt.clientY - huePosition.top;
                var updatedHue = getHueFromPosition(y, sliderDivRef.current.clientHeight);
                onChange(updatedHue);
                break;
            }
            default: {
                var x = evt.clientX - huePosition.left;
                var updatedHue = getHueFromPosition(x, sliderDivRef.current.clientWidth);
                onChange(updatedHue);
            }
        }
    }, [onChange]);
    var onPointerDown = react.useCallback(function (evt) {
        evt.target.setPointerCapture(evt.pointerId);
        onInteractionStart();
        setIsInteracting(true);
        updateHue(evt);
    }, [onInteractionStart, updateHue]);
    var onPointerUp = react.useCallback(function (evt) {
        evt.target.releasePointerCapture(evt.pointerId);
        onInteractionEnd();
        setIsInteracting(false);
    }, [onInteractionEnd]);
    var onMouseDown = react.useCallback(function (evt) {
        onInteractionStart();
        setIsInteracting(true);
        updateHue(evt);
    }, [onInteractionStart, updateHue]);
    var onMove = react.useCallback(function (evt) {
        if (isInteracting) {
            updateHue(evt);
        }
    }, [isInteracting, updateHue]);
    var onMouseUp = react.useCallback(function () {
        onInteractionEnd();
        setIsInteracting(false);
    }, [onInteractionEnd]);
    // Setup pointer events for supported browsers for two reasons:
    //   1. It allows for pointer capture which allows for continued
    //      interaction even when the cursor/pointer outside of picker
    //   2. It allows for unified code across devices (mobile and desktop)
    var interactionCallbacks = (window.PointerEvent)
        ? {
            onPointerDown: onPointerDown,
            onPointerMove: onMove,
            onPointerUp: onPointerUp,
        }
        : {
            onMouseDown: onMouseDown,
            onMouseMove: onMove,
            onMouseUp: onMouseUp,
        };
    var sliderStyle = (layout === HueSlider.LAYOUTS.VERTICAL)
        ? {
            top: (hue / 360) * 100 + "%",
            backgroundColor: hueColor,
        }
        : {
            left: (hue / 360) * 100 + "%",
            backgroundColor: hueColor,
        };
    return (jsxRuntime.jsx("div", __assign({ className: classNames__default['default'](styles$2.hue_slider, className, (_b = {}, _b[styles$2.vertical] = layout === HueSlider.LAYOUTS.VERTICAL, _b)), ref: sliderDivRef, title: "Hue" }, interactionCallbacks, { children: jsxRuntime.jsx("div", { className: classNames__default['default'](styles$2.hue_slider_picker, pickerClassName), style: sliderStyle }, void 0) }), void 0));
};
HueSlider.LAYOUTS = {
    HORIZONTAL: 'HORIZONTAL',
    VERTICAL: 'VERTICAL',
};

var css_248z$1 = ".SaturationValueSelector-module_saturation_value_selector__3JODT {\n  position: relative;\n  box-sizing: border-box;\n  height: 100%;\n  overflow: hidden;\n  margin-left: 11px;\n  margin-right: 11px;\n  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, #000000 100%), linear-gradient(to left, rgba(255, 255, 255, 0) 0%, #ffffff 100%);\n  background-color: #ffffff;\n}\n.SaturationValueSelector-module_saturation_value_selector__3JODT .SaturationValueSelector-module_saturation_value_picker__15E1- {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 28px;\n  height: 28px;\n  box-sizing: border-box;\n  border: 2px solid #ffffff;\n  box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.5);\n  border-radius: 14px;\n  cursor: pointer;\n  transform: translate(-50%, -50%);\n}";
var styles$1 = {"saturation_value_selector":"SaturationValueSelector-module_saturation_value_selector__3JODT","saturation_value_picker":"SaturationValueSelector-module_saturation_value_picker__15E1-"};
styleInject(css_248z$1);

var SaturationValueSelector = function (_a) {
    var className = _a.className, pickerClassName = _a.pickerClassName, hue = _a.hue, saturation = _a.saturation, value = _a.value, onChange = _a.onChange, _b = _a.onInteractionStart, onInteractionStart = _b === void 0 ? function () { } : _b, _c = _a.onInteractionEnd, onInteractionEnd = _c === void 0 ? function () { } : _c;
    var _d = react.useState(false), isInteracting = _d[0], setIsInteracting = _d[1];
    var selectorDivRef = react.useRef(null);
    var hueColor = hsvToHex(hue, 1, 1);
    var hex = hsvToHex(hue, saturation, value);
    var updateSaturationValue = react.useCallback(function (evt) {
        if (!selectorDivRef.current) {
            return;
        }
        var svPosition = selectorDivRef.current.getBoundingClientRect();
        var x = evt.clientX - svPosition.left;
        var y = evt.clientY - svPosition.top;
        var updatedSaturationValue = getSaturationValueFromPosition(x, y, selectorDivRef.current.clientWidth, selectorDivRef.current.clientHeight);
        onChange(updatedSaturationValue);
    }, [onChange]);
    var onPointerDown = react.useCallback(function (evt) {
        evt.target.setPointerCapture(evt.pointerId);
        onInteractionStart();
        setIsInteracting(true);
        updateSaturationValue(evt);
    }, [onInteractionStart, updateSaturationValue]);
    var onPointerUp = react.useCallback(function (evt) {
        evt.target.releasePointerCapture(evt.pointerId);
        onInteractionEnd();
        setIsInteracting(false);
    }, [onInteractionEnd]);
    var onMouseDown = react.useCallback(function (evt) {
        onInteractionStart();
        setIsInteracting(true);
        updateSaturationValue(evt);
    }, [onInteractionStart, updateSaturationValue]);
    var onMove = react.useCallback(function (evt) {
        if (isInteracting) {
            updateSaturationValue(evt);
        }
    }, [isInteracting, updateSaturationValue]);
    var onMouseUp = react.useCallback(function () {
        onInteractionEnd();
        setIsInteracting(false);
    }, [onInteractionEnd]);
    // Setup pointer events for supported browsers for two reasons:
    //   1. It allows for pointer capture which allows for continued
    //      interaction even when the cursor/pointer outside of picker
    //   2. It allows for unified code across devices (mobile and desktop)
    var interactionCallbacks = (window.PointerEvent)
        ? {
            onPointerDown: onPointerDown,
            onPointerMove: onMove,
            onPointerUp: onPointerUp,
        }
        : {
            onMouseDown: onMouseDown,
            onMouseMove: onMove,
            onMouseUp: onMouseUp,
        };
    return (jsxRuntime.jsx("div", __assign({ className: classNames__default['default'](styles$1.saturation_value_selector, className), style: {
            backgroundColor: hueColor,
        }, ref: selectorDivRef, title: "Saturation and Value" }, interactionCallbacks, { children: jsxRuntime.jsx("div", { className: classNames__default['default'](styles$1.saturation_value_picker, pickerClassName), style: {
                left: saturation * 100 + "%",
                top: (1 - value) * 100 + "%",
                backgroundColor: hex,
            } }, void 0) }), void 0));
};

var css_248z = ".ReactColorPicker-module_react_color_picker__1OEfS {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_saturation_value_selector__1Oyfo {\n  flex: 1 1 0;\n  margin-bottom: 10px;\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_details__106p_ {\n  display: flex;\n  align-items: center;\n  margin-top: 10px;\n  margin-left: 11px;\n  margin-right: 11px;\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_details__106p_ .ReactColorPicker-module_swatch__3kHFV {\n  width: 32px;\n  height: 32px;\n  margin-right: 10px;\n  border: 1px solid #ccc;\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_details__106p_ .ReactColorPicker-module_hex_value__10kKY {\n  width: 60px;\n  margin-left: 5px;\n}";
var styles = {"react_color_picker":"ReactColorPicker-module_react_color_picker__1OEfS","saturation_value_selector":"ReactColorPicker-module_saturation_value_selector__1Oyfo","details":"ReactColorPicker-module_details__106p_","swatch":"ReactColorPicker-module_swatch__3kHFV","hex_value":"ReactColorPicker-module_hex_value__10kKY"};
styleInject(css_248z);

var ReactColorPicker = function (_a) {
    var _b = _a.className, className = _b === void 0 ? null : _b, _c = _a.color, color = _c === void 0 ? '#3cd6bf' : _c, hueClassName = _a.hueClassName, huePickerClassName = _a.huePickerClassName, saturationValueClassName = _a.saturationValueClassName, saturationValuePickerClassName = _a.saturationValuePickerClassName, _d = _a.showHex, showHex = _d === void 0 ? true : _d, _e = _a.showSwatch, showSwatch = _e === void 0 ? true : _e, _f = _a.onChange, onChange = _f === void 0 ? function () { } : _f, _g = _a.onInteractionStart, onInteractionStart = _g === void 0 ? function () { } : _g, _h = _a.onInteractionEnd, onInteractionEnd = _h === void 0 ? function () { } : _h, rest = __rest(_a, ["className", "color", "hueClassName", "huePickerClassName", "saturationValueClassName", "saturationValuePickerClassName", "showHex", "showSwatch", "onChange", "onInteractionStart", "onInteractionEnd"]);
    var sanitizedColor = sanitizeHex(color || '#000000');
    var _j = react.useState(sanitizedColor), hex = _j[0], setHex = _j[1];
    var _k = react.useState(hexToHsv(sanitizedColor)), hsv = _k[0], setHsv = _k[1];
    var _l = react.useState(false), isInteracting = _l[0], setIsInteracting = _l[1];
    // Used when editing the hex through the input
    var _m = react.useState(hex), tempHex = _m[0], setTempHex = _m[1];
    var hsvRef = react.useRef(hsv);
    var hexRef = react.useRef(hex);
    // Set the hex and hsv states/refs with updated data
    var setColor = function (updatedHex, updatedHsv) {
        hexRef.current = updatedHex;
        hsvRef.current = updatedHsv;
        setHex(updatedHex);
        setTempHex(updatedHex);
        setHsv(updatedHsv);
        onChange(updatedHex);
    };
    // Helper to set the color when HSV change
    var setColorFromHsv = function (updatedHsv) { return setColor(hsvToHex(updatedHsv.hue, updatedHsv.saturation, updatedHsv.value), updatedHsv); };
    // Helper to set the color when hex changes
    var setColorFromHex = function (updatedHex) { return setColor(updatedHex, hexToHsv(updatedHex)); };
    var onControlInteractionStart = function () {
        setIsInteracting(true);
        onInteractionStart();
    };
    var onControlInteractionEnd = function () {
        setIsInteracting(false);
        onInteractionEnd();
    };
    // Event handler for hex input changes (on blur and enter pressed)
    var onHexChange = function (value) {
        // Strip out invalid characters
        var sanitizedHex = sanitizeHex(value);
        setColorFromHex(sanitizedHex);
    };
    // Update color when the passed value changes
    react.useEffect(function () {
        if (color !== hexRef.current && !isInteracting) {
            var sanitizedHex = sanitizeHex(color || '#000000');
            setColorFromHex(sanitizedHex);
        }
    }, [color]);
    var hue = hsv.hue, saturation = hsv.saturation, value = hsv.value;
    return (jsxRuntime.jsxs("div", __assign({ className: "" + styles.react_color_picker + (className ? " " + className : '') }, rest, { children: [jsxRuntime.jsx("div", __assign({ className: styles.saturation_value_selector }, { children: jsxRuntime.jsx(SaturationValueSelector, { className: saturationValueClassName, pickerClassName: saturationValuePickerClassName, hue: hue, saturation: saturation, value: value, onChange: function (updatedSaturationValue) { return setColorFromHsv(__assign(__assign({}, hsvRef.current), updatedSaturationValue)); }, onInteractionStart: onControlInteractionStart, onInteractionEnd: onControlInteractionEnd }, void 0) }), void 0),
            jsxRuntime.jsx(HueSlider, { className: hueClassName, pickerClassName: huePickerClassName, hue: hue, onChange: function (updatedHue) { return setColorFromHsv(__assign(__assign({}, hsvRef.current), { hue: updatedHue })); }, onInteractionStart: onControlInteractionStart, onInteractionEnd: onControlInteractionEnd }, void 0),
            (showHex || showSwatch) && (jsxRuntime.jsxs("div", __assign({ className: styles.details }, { children: [showSwatch && (jsxRuntime.jsx("div", { className: styles.swatch, style: {
                            backgroundColor: hex,
                        }, title: "Swatch" }, void 0)),
                    showHex && (jsxRuntime.jsxs("label", { children: [jsxRuntime.jsx("span", { children: "Hex:" }, void 0),
                            jsxRuntime.jsx("input", { className: styles.hex_value, value: tempHex, onChange: function (evt) { return setTempHex(evt.target.value); }, onBlur: function (evt) { return onHexChange(evt.target.value); }, onKeyDown: function (evt) {
                                    var inputTarget = evt.target;
                                    if (evt.key === 'Enter') {
                                        onHexChange(inputTarget.value);
                                    }
                                    else if (evt.key === 'Esc' || evt.key === 'Escape') {
                                        // eslint-disable-next-line no-param-reassign
                                        inputTarget.value = hexRef.current;
                                        inputTarget.blur();
                                    }
                                } }, void 0)] }, void 0))] }), void 0))] }), void 0));
};

exports.HueSlider = HueSlider;
exports.SaturationValueSelector = SaturationValueSelector;
exports.default = ReactColorPicker;
//# sourceMappingURL=index.js.map
